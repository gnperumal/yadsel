#!/usr/bin/env python

"""
This module provide a tool for doing migration by shell line
@author Marinho Brandao
@creation 2007-05-25
"""

import sys, os
from yadsel import core, drivers

try:
    import simplejson
except ImportError, e:
    pass

AVAILABLE_ACTIONS = ( core.ACTION_UP, core.ACTION_DOWN, )

MODE_HIDDEN = 'hidden'
MODE_STEPS = 'steps'
MODE_INTERACTIVE = 'interactive'
MODE_OUTPUT = 'output'
AVAILABLE_MODES = ( MODE_HIDDEN, MODE_STEPS, MODE_INTERACTIVE, MODE_OUTPUT )
DEFAULT_YADSEL_FILENAME = '.yadsel'

def print_header():
    print "Yadsel Tool // http://code.google.com/p/yadsel/\n"

def print_help():
    temp = [
            "Invalid syntax. You must declare required parameters, like below:",
            "",
            "  driver=<drive_name>\n",
            "  path=<version_files_path>\n",
            "  dsn=<dsn>\n",
            "  user=<username>\n",
            "  pass=<password>\n\toptional. Default: empty\n",
            "  from=<current_version>\n\toptional. Default: latest version of history control\n",
            "  to=<new_version_number>\n\toptional. Default: latest available version\n",
            "  action=[%s]\n\toptional. Default: %s\n" %( ''.join([m+'|' for m in AVAILABLE_ACTIONS])[:-1], core.ACTION_UP ),
            "  mode=[%s]\n\toptional. Default: %s\n" %( ''.join([m+'|' for m in AVAILABLE_MODES])[:-1], MODE_HIDDEN ),
            "  test\n\toptional. Turns off persistent changings on database\n",
            "  history\n\toptional. Turns on history control on database",
            "  silent\n\toptional. Only shows error messages without stop upgrade/downgrade process",
            "  log\n\toptional. Register the log of changes maked on a table called 'yadsel_log'",
           ]

    print ''.join([l+"\n" for l in temp])

def print_if( condition, s ):
    if condition: print s

def do(versions_path, driver_type, dsn, user, passwd, action, current_version, 
        new_version, mode, test, history, silent, log):
    """Executes the upgrade or downgrade"""
    versions_path = versions_path or '.'
    action = action or 'up'

    if not dsn:
        print "Invalid DSN!"
        sys.exit(1)

    connection = None

    if driver_type == "firebird":
        try:
            import kinterbasdb
        except:
            print "A Python extension called 'kinterbasdb' was not found!"
            sys.exit(1)

        if dsn:
            connection = kinterbasdb.connect(dsn=dsn, user=user, password=passwd)
            
        driver = drivers.Firebird
    elif driver_type == "mssql":
        try:
            import pymssql
        except:
            print "A Python extension called 'pymssql' was not found!"
            sys.exit(1)

        if dsn:
            connection = None #pymssql.connect(dsn=dsn, user=user, password=passwd)
            
        driver = drivers.MSSQL
    elif driver_type == "mysql":
        driver = drivers.MySQL
    elif driver_type == "sqlite":
        try:
            from pysqlite2 import dbapi2 as sqlite
        except:
            print "A Python extension called 'pysqlite2' was not found!"
            sys.exit(1)

        if dsn:
            connection = sqlite.connect(dsn)

        driver = drivers.SQLite
    else:
        print "Only drivers 'Firebird', 'MySQL' and 'SQLite' are supported!"
        sys.exit(1)

    # Instantiates version controller
    controller = core.Controller(driver, connection=connection)

    print_if( mode != MODE_HIDDEN, "Driver: %s" % controller.driver.__class__.__name__ )

    # Gets current version
    if history and not current_version:
        controller.load_current_version_from_history()
    else:
        controller.current_version = current_version

    controller.load_versions_from_path(versions_path)

    if action == core.ACTION_UP:
        print_if( mode != MODE_HIDDEN, "Upgrading..." )

        # Prints script if mode is 'output'
        if mode == MODE_OUTPUT:
            script = controller.script_for_upgrade(to=new_version)

            # Print scripts
            for v in script:
                print "/* Version", v, "*/"
                for cmd in script[v]:
                    print "", cmd
        elif mode == MODE_HIDDEN:
            controller.upgrade(current=current_version, to=new_version, test=test, silent=silent, log=log)
        elif mode == MODE_STEPS:
            # First step for build scripts for cache and gets steps count
            controller.upgrade(current=current_version, to=new_version, cacheable=True, force=True, step=0, test=test, silent=silent, log=log)
            print 'Step %d of %d: ""' %( 1, controller.cache['steps_count'] )

            # Loop for next steps (if exists)
            if controller.cache['steps_count'] > 1:
                for i in range(1, controller.cache['steps_count']):
                    controller.upgrade(cacheable=True, step=i, test=test, silent=silent, log=log)
                    print 'Step %d of %d: "%s"' %( i+1, controller.cache['steps_count'], "" )
        else:
            controller.upgrade(current=current_version, to=new_version, test=test, silent=silent, log=log)
            
    elif action == core.ACTION_DOWN:
        print_if( mode != MODE_HIDDEN, "Downgrading..." )

        # Prints script if mode is 'output'
        if mode == MODE_OUTPUT:
            script = controller.script_for_downgrade(to=new_version)

            # Print scripts
            for v in script:
                print "/* Version", v, "*/"
                for cmd in script[v]:
                    print "", cmd
        elif mode == MODE_HIDDEN:
            controller.downgrade(test=test)
        elif mode == MODE_STEPS:
            # First step for build scripts for cache and gets steps count
            controller.downgrade(cacheable=True, force=True, step=0, test=test)
            print 'Step %d of %d: ""' %( 1, controller.cache['steps_count'] )

            # Loop for next steps (if exists)
            if controller.cache['steps_count'] > 1:
                for i in range(1, controller.cache['steps_count']):
                    controller.downgrade(cacheable=True, step=i, test=test)
                    print 'Step %d of %d: "%s"' %( i+1, controller.cache['steps_count'], "" )
        else:
            controller.downgrade(test=test)

def do_from_dict(keys):
    # Does the (up|down)grade
    do(versions_path=keys.get('path', None),
       driver_type=keys.get('driver', '').lower(),
       dsn=keys.get('dsn', None),
       action=keys.get('action', None),
       user=keys.get('user', None),
       passwd=keys.get('pass', None),
       current_version=keys.get('from', None),
       new_version=keys.get('to', None),
       mode=keys.get('mode', None),
       test=keys.get('test', False),
       history=keys.get('history', False),
       silent=keys.get('silent', False),
       log=keys.get('log', False),
       )

def do_from_file(filename, namespace=None):
    """Executes from a project file"""
    fp = file(filename)
    cont = fp.read()
    fp.close()

    json = simplejson.loads(cont)

    if namespace:
        do_from_dict(json[namespace])
    else:
        for keys in json.values():
            try:
                do_from_dict(keys)
            except:
                print e, "\n"

if __name__ == '__main__':
    print_header()

    versions_path = dsn = user = current_version = None
    action = core.ACTION_UP
    new_version = 0
    passwd = ''
    mode = MODE_HIDDEN
    log = silent = test = history = False

    if len(sys.argv) == 1 or sys.argv[1].find('=') == -1:
        if os.path.isfile(DEFAULT_YADSEL_FILENAME):
            ns = len(sys.argv) == 2 and sys.argv[1] or None
            do_from_file(DEFAULT_YADSEL_FILENAME, ns)
            sys.exit(0)

    for arg in sys.argv:
        if arg.startswith('path='):
            versions_path = arg.split('=')[1]
        elif arg.startswith('driver='):
            driver_type = arg.split('=')[1].lower()
        elif arg.startswith('dsn='):
            dsn = arg.split('=')[1]
        elif arg.startswith('user='):
            user = arg.split('=')[1] or action
        elif arg.startswith('pass='):
            passwd = arg.split('=')[1]
        elif arg.startswith('action='):
            action = arg.split('=')[1] or passwd
        elif arg.startswith('from='):
            current_version = int(arg.split('=')[1])
        elif arg.startswith('to='):
            new_version = int(arg.split('=')[1]) or new_version
        elif arg.startswith('mode='):
            mode = arg.split('=')[1]
        elif arg == 'test':
            test = True
        elif arg == 'history':
            history = True
        elif arg == 'silent':
            silent = True
        elif arg == 'log':
            log = True

    if not versions_path or not driver_type:
        print_help()
        sys.exit(1)

    # Does the (up|down)grade
    do(versions_path=versions_path,
       driver_type=driver_type,
       dsn=dsn,
       action=action,
       user=user,
       passwd=passwd,
       current_version=current_version,
       new_version=new_version,
       mode=mode,
       test=test,
       history=history,
       silent=silent,
       log=log,
       )

